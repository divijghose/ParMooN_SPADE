<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ParMooN(SPADE): BLAS and LAPACK routines used in the code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ParMooN(SPADE)<span id="projectnumber">&#160;1.10</span>
   </div>
   <div id="projectbrief">Stochastic ParMooN for analysis, design and estimation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">BLAS and LAPACK routines used in the code </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Contents</h1>
<ol type="1">
<li>Monte Carlo realization generation <br  />
 a. SVD of Covariance Matrix<br  />
 b. Multiplication of truncated left singular value matrix with standard deviation matrix</li>
<li>DO Initialization <br  />
 a. SVD of perturbation matrix <br  />
 b. Calculation of Projection Matrix</li>
</ol>
<h1><a class="anchor" id="autotoc_md2"></a>
Monte Carlo Realization generation</h1>
<p >Back to Contents</p>
<h2><a class="anchor" id="autotoc_md3"></a>
SVD of Covariance matrix</h2>
<p >Back to Contents </p>
<h3><a class="anchor" id="autotoc_md4"></a>
Code Snippet</h3>
<div class="fragment"><div class="line">double superb[std::min(N_U, N_U) - 1];</div>
<div class="line"> </div>
<div class="line">double *S = new double[N_U];</div>
<div class="line">double *U = new double[N_U * N_U];</div>
<div class="line">double *Vt = new double[N_U * N_U];</div>
<div class="line"> </div>
<div class="line">info = LAPACKE_dgesvd(LAPACK_ROW_MAJOR, &#39;A&#39;, &#39;A&#39;, m1, n, C, lda,S, U, ldu, Vt, ldvt, superb);</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; endl</div>
<div class="line">        &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">if (info &gt; 0)</div>
<div class="line">{</div>
<div class="line">    printf(&quot;The algorithm computing SVD failed to converge.\n&quot;);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; &quot; SVD COMPUTED&quot; &lt;&lt; endl;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Purpose</h3>
<p >DGESVD computes the singular value decomposition (SVD) of a real </p><div class="fragment"><div class="line"> vectors. The SVD is written</div>
<div class="line"> </div>
<div class="line">      C = U * S * Vt</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> __Note that the routine returns V**T, not V.__</div>
<div class="line"> </div>
<div class="line">#### Input</div>
<div class="line">```MATRIX_LAYOUT</div>
</div><!-- fragment --><p> indicates whether the input and output matrices are stored in row major order or column major order, where:\ matrix_layout = <code>LAPACK_ROW_MAJOR</code>, the matrices are stored in row major order.</p>
<div class="fragment"><div class="line"> {JOBU```}</div>
<div class="line">Specifies options for computing all or part of the matrix\</div>
<div class="line">U := ```&#39;A&#39;```:  all M columns of U are returned in array</div>
<div class="line"> </div>
<div class="line">```JOBVT``` is CHARACTER*1 \</div>
<div class="line">Specifies options for computing all or part of the matrix\</div>
<div class="line">VT := ```&#39;A&#39;```:  all N rows of V**T are returned in the array VT;</div>
<div class="line"> </div>
<div class="line">```M``` is INTEGER \</div>
<div class="line">The number of rows of the input matrix ```C``` (Covariance Matrix). \</div>
<div class="line">```m1 = N_U```.</div>
<div class="line"> </div>
<div class="line">```N``` is INTEGER \</div>
<div class="line">The number of columns of the input matrix  ```C``` (Covariance Matrix). \</div>
<div class="line">```n = N_U```.</div>
<div class="line"> </div>
<div class="line">A is DOUBLE PRECISION array, dimension (LDA,N), in our case ```C``` (Covariance Matrix)\</div>
<div class="line">On entry, the M-by-N matrix ```C```. \</div>
<div class="line">On exit, </div>
<div class="line">if ```JOBU != &#39;O&#39;``` and ```JOBVT != &#39;O&#39;```, the contents of ```C</div>
</div><!-- fragment --><p> are destroyed.</p>
<div class="fragment"><div class="line"> {LDA```}</div>
<div class="line">The leading dimension of the array ```C```. \</div>
<div class="line">LDA &gt;= max(1,M)\</div>
<div class="line">```lda = N_U</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {S```}</div>
<div class="line">The singular values of A, sorted so that S(i) &gt;= S(i+1).</div>
<div class="line"> </div>
<div class="line">```U ``` is DOUBLE PRECISION array, dimension ```LDU x N_U``` \</div>
<div class="line">If ```JOBU = &#39;A&#39;```, U contains the M-by-M orthogonal matrix U;</div>
<div class="line"> </div>
<div class="line">```LDU``` is INTEGER \</div>
<div class="line">The leading dimension of the array U.\</div>
<div class="line">```ldu = N_U</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {Vt```}</div>
<div class="line">If JOBVT = &#39;A&#39;, ```Vt``` contains the ```N_U x N_U``` orthogonal matrix V**T</div>
<div class="line"> </div>
<div class="line">```LDVT``` is INTEGER \</div>
<div class="line">The leading dimension of the array VT. \</div>
<div class="line">```ldvt = N_U</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md6"></a>
Output</h3>
<div class="fragment"><div class="line"> {S[i],}</div>
<div class="line">```U, N_U x N_U``` \</div>
<div class="line">```Vt, N_U x N_U</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md7"></a>
Multiplication of truncated left singular value matrix with standard deviation matrix</h2>
<p >Back to Contents</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Purpose</h3>
<p >The dgemm routine calculates the product of double precision matrices \ </p><div class="fragment"><div class="line">Here, we want \</div>
<div class="line">``` RealizationVector = Ut x Z </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Code snippet</h3>
<div class="fragment"><div class="line"> {cblas_dgemm(CblasRowMajor,}</div>
<div class="line"> </div>
<div class="line">#### Input </div>
<div class="line">```CblasRowMajor``` \</div>
<div class="line">Indicates that the matrices are stored in row major order, with the elements of each row of the matrix stored contiguously.</div>
<div class="line"> </div>
<div class="line">```CblasNoTrans``` \</div>
<div class="line">Enumeration type</div>
<div class="line">indicating that the matrices A</div>
<div class="line">and B</div>
<div class="line">should not be transposed or conjugate transposed before multiplication. </div>
<div class="line"> </div>
<div class="line">m, n, k</div>
<div class="line">Integers indicating the size of the matrices:</div>
<div class="line"> </div>
<div class="line">A</div>
<div class="line">: m</div>
<div class="line">rows by k</div>
<div class="line">columns\</div>
<div class="line">B</div>
<div class="line">: k</div>
<div class="line">rows by n</div>
<div class="line">columns\</div>
<div class="line">C</div>
<div class="line">: m</div>
<div class="line">rows by n</div>
<div class="line">columns\</div>
<div class="line">Here, ```A = Ut```, ```B=Z```, ```C = RealizationVector```, hence \</div>
<div class="line">```m = N_U``` \</div>
<div class="line">```n = N_Realisations``` \</div>
<div class="line">```k = modDim</div>
</div><!-- fragment --><p >alpha Real value used to scale the product of matrices A and B.\ </p><div class="fragment"><div class="line">A \</div>
<div class="line">Array used to store matrix A (```Ut``` in our case)</div>
<div class="line"> </div>
<div class="line">k \</div>
<div class="line">Leading dimension of array A (```Ut```)</div>
<div class="line">, or the number of elements between successive rows (for row major storage)</div>
<div class="line">in memory. \</div>
<div class="line">```k = modDim</div>
</div><!-- fragment --><p >B \ Array used to store matrix B (<code>Z</code> in our case)</p>
<p >n \ Leading dimension of array B (<code>Z</code>) , or the number of elements between successive rows (for row major storage) in memory. \ </p><div class="fragment"><div class="line">beta \</div>
<div class="line">Real value used to scale matrix C (```RealizationVector```)</div>
<div class="line">```beta = 0.0</div>
</div><!-- fragment --><p >C \ Array used to store matrix C (<code>RealizationVector</code> in our case)</p>
<p >n Leading dimension of array C , or the number of elements between successive rows (for row major storage) in memory. </p><div class="fragment"><div class="line">________________________________________________________</div>
<div class="line">## DO Initialization</div>
<div class="line">[Back to Contents](#contents)</div>
<div class="line">### SVD of perturbation matrix</div>
<div class="line">[Back to Contents](#contents)</div>
<div class="line">1. [If N_Realisations &gt; N_U](#if-number-of-realisations-is-greater-than-number-of-degrees-of-freedom)</div>
<div class="line">2. [If N_U &gt; N_Realisations](#if-number-of-degrees-of-freedom-is-greater-than-number-of-realisations)</div>
<div class="line"> </div>
<div class="line">#### If number of realisations is greater than number of degrees of freedom </div>
<div class="line">[Back to SVD of perturbation matrix](#svd-of-perturbation-matrix) \</div>
<div class="line">```min(N_R,N_U) =  N_U</div>
</div><!-- fragment --><div class="fragment"><div class="line">//Here, minDim = N_U</div>
<div class="line">MKL_INT mDO = N_U, nDO = N_Realisations, ldaDO = N_Realisations, lduDO = minDim, ldvtDO = N_Realisations, infoDO;</div>
<div class="line">double superbDO[minDim-1];</div>
<div class="line"> </div>
<div class="line">double* PerturbationVectorCopy = new double[N_U * N_Realisations]();</div>
<div class="line">memcpy(PerturbationVectorCopy,PerturbationVector,N_U*N_Realisations*SizeOfDouble);</div>
<div class="line"> </div>
<div class="line">double* Sg = new double[minDim];</div>
<div class="line">double* L = new double[N_U*minDim];</div>
<div class="line">double* Rt = new double[minDim*N_Realisations];</div>
<div class="line"> </div>
<div class="line">infoDO = LAPACKE_dgesvd( LAPACK_ROW_MAJOR, &#39;S&#39;, &#39;N&#39;, mDO, nDO, PerturbationVectorCopy, ldaDO,</div>
<div class="line">                    Sg, L, lduDO, Rt, ldvtDO, superbDO );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">if( infoDO &gt; 0 ) {</div>
<div class="line">    printf( &quot;The algorithm computing SVD for DO failed to converge.\n&quot; );</div>
<div class="line">    exit( 1 );</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; &quot; DO SVD COMPUTED &quot; &lt;&lt;endl;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Purpose</h3>
<p >DGESVD computes the singular value decomposition (SVD) of a real </p><div class="fragment"><div class="line"> vectors. The SVD is written</div>
<div class="line"> </div>
<div class="line">      PerturbationVector = L * Sg * Rt</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> __Note that the routine returns R**T, not R.__</div>
<div class="line"> </div>
<div class="line">#### Input</div>
<div class="line">```MATRIX_LAYOUT</div>
</div><!-- fragment --><p> indicates whether the input and output matrices are stored in row major order or column major order, where:\ matrix_layout = <code>LAPACK_ROW_MAJOR</code>, the matrices are stored in row major order.</p>
<div class="fragment"><div class="line"> {JOBU```}</div>
<div class="line">Specifies options for computing all or part of the matrix \</div>
<div class="line">L := ```&#39;S&#39;```:  the first ```min(N_U,N_Realisation)``` columns of U (the left singular matrix)\</div>
<div class="line">__Here we are assuming ```N_Realisations &gt; N_U```, hence U will have dimension ```N_U x N_U```__</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">```JOBVT``` is CHARACTER*1 \</div>
<div class="line">Specifies options for computing all or part of the matrix\</div>
<div class="line">VT := ```&#39;N&#39;```: no rows of V**T (no right singular vectors) are computed.\</div>
<div class="line"> </div>
<div class="line">```M``` is INTEGER \</div>
<div class="line">The number of rows of the input matrix ```PerturbationVectorCopy``` (Copy of ```PerturbationVector```). \</div>
<div class="line">```mDO = N_U```.</div>
<div class="line"> </div>
<div class="line">```N``` is INTEGER \</div>
<div class="line">The number of columns of the input matrix  ```PerturbationVectorCopy``` (Copy of ```PerturbationVector```). \</div>
<div class="line">```nDO = N_Realisations```.</div>
<div class="line"> </div>
<div class="line">A is DOUBLE PRECISION array, dimension (LDA,N), in our case ```PerturbationVectorCopy``` (Copy of ```PerturbationVector```)\</div>
<div class="line">On entry, the M-by-N matrix ```PerturbationVectorCopy```. \</div>
<div class="line">On exit, </div>
<div class="line">if ```JOBU != &#39;O&#39;``` and ```JOBVT != &#39;O&#39;```, the contents of ```PerturbationVectorCopy</div>
</div><!-- fragment --><p> are destroyed.(Hence we are using <code>PerturbationVectorCopy</code> and not <code>PerturbationVector</code>)</p>
<div class="fragment"><div class="line"> {LDA```}</div>
<div class="line">The leading dimension of the array ```PerturbationVectorCopy```. \</div>
<div class="line">LDA &gt;= max(1,M)\</div>
<div class="line">```lda = N_Realisations``` \</div>
<div class="line">**Assumption of ```N_Realisations &gt; N_U``` also applies here**</div>
<div class="line"> </div>
<div class="line">```Sg``` is DOUBLE PRECISION array, dimension (min(M,N))= ```N_U```.  </div>
<div class="line">The singular values of A, sorted so that S(i) &gt;= S(i+1).</div>
<div class="line"> </div>
<div class="line">```U ``` is DOUBLE PRECISION array, dimension ```LDU x N_U``` \      </div>
<div class="line">If JOBU = &#39;S&#39;, U contains the first min(m,n) columns of U</div>
<div class="line">(the left singular vectors, stored columnwise)</div>
<div class="line">          </div>
<div class="line">```LDU``` is INTEGER \</div>
<div class="line">The leading dimension of the array U.\</div>
<div class="line">```ldu = N_U</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Output</h3>
<div class="fragment"><div class="line"> {Sg[i],}</div>
<div class="line">```L, N_U x N_U``` \</div>
<div class="line">________________________________________________________</div>
<div class="line"> </div>
<div class="line">#### If number of degrees of freedom is greater than number of realisations </div>
<div class="line">[Back to SVD of perturbation matrix](#svd-of-perturbation-matrix) \</div>
<div class="line">```min(N_R,N_U) =  N_Realisations</div>
</div><!-- fragment --><div class="fragment"><div class="line">//Here, minDim = N_Realisations</div>
<div class="line">MKL_INT mDO = N_U, nDO = N_Realisations, ldaDO = N_Realisations, lduDO = minDim, ldvtDO = N_Realisations, infoDO;</div>
<div class="line">double superbDO[minDim-1];</div>
<div class="line"> </div>
<div class="line">double* PerturbationVectorCopy = new double[N_U * N_Realisations]();</div>
<div class="line">memcpy(PerturbationVectorCopy,PerturbationVector,N_U*N_Realisations*SizeOfDouble);</div>
<div class="line"> </div>
<div class="line">double* Sg = new double[minDim];</div>
<div class="line">double* L = new double[N_U*minDim];</div>
<div class="line">double* Rt = new double[minDim*N_Realisations];</div>
<div class="line"> </div>
<div class="line">infoDO = LAPACKE_dgesvd( LAPACK_ROW_MAJOR, &#39;S&#39;, &#39;N&#39;, mDO, nDO, PerturbationVectorCopy, ldaDO,</div>
<div class="line">                    Sg, L, lduDO, Rt, ldvtDO, superbDO );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">if( infoDO &gt; 0 ) {</div>
<div class="line">    printf( &quot;The algorithm computing SVD for DO failed to converge.\n&quot; );</div>
<div class="line">    exit( 1 );</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; &quot; DO SVD COMPUTED &quot; &lt;&lt;endl;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Purpose</h3>
<p >DGESVD computes the singular value decomposition (SVD) of a real </p><div class="fragment"><div class="line"> vectors. The SVD is written</div>
<div class="line"> </div>
<div class="line">      PerturbationVector = L * Sg * Rt</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> __Note that the routine returns R**T, not R.__</div>
<div class="line"> </div>
<div class="line">#### Input</div>
<div class="line">```MATRIX_LAYOUT</div>
</div><!-- fragment --><p> indicates whether the input and output matrices are stored in row major order or column major order, where:\ matrix_layout = <code>LAPACK_ROW_MAJOR</code>, the matrices are stored in row major order.</p>
<div class="fragment"><div class="line"> {JOBU```}</div>
<div class="line">Specifies options for computing all or part of the matrix \</div>
<div class="line">L := ```&#39;S&#39;```:  the first ```min(N_U,N_Realisation)``` columns of U (the left singular matrix)\</div>
<div class="line">__Here we are assuming ```N_U &gt; N_Realisations```, hence U will have dimension ```N_U x N_Realisations```__</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">```JOBVT``` is CHARACTER*1 \</div>
<div class="line">Specifies options for computing all or part of the matrix\</div>
<div class="line">VT := ```&#39;N&#39;```: no rows of V**T (no right singular vectors) are computed.\</div>
<div class="line"> </div>
<div class="line">```M``` is INTEGER \</div>
<div class="line">The number of rows of the input matrix ```PerturbationVectorCopy``` (Copy of ```PerturbationVector```). \</div>
<div class="line">```mDO = N_U```.</div>
<div class="line"> </div>
<div class="line">```N``` is INTEGER \</div>
<div class="line">The number of columns of the input matrix  ```PerturbationVectorCopy``` (Copy of ```PerturbationVector```). \</div>
<div class="line">```nDO = N_Realisations```.</div>
<div class="line"> </div>
<div class="line">A is DOUBLE PRECISION array, dimension (LDA,N), in our case ```PerturbationVectorCopy``` (Copy of ```PerturbationVector```)\</div>
<div class="line">On entry, the M-by-N matrix ```PerturbationVectorCopy```. \</div>
<div class="line">On exit, </div>
<div class="line">if ```JOBU != &#39;O&#39;``` and ```JOBVT != &#39;O&#39;```, the contents of ```PerturbationVectorCopy</div>
</div><!-- fragment --><p> are destroyed.(Hence we are using <code>PerturbationVectorCopy</code> and not <code>PerturbationVector</code>)</p>
<div class="fragment"><div class="line"> {LDA```}</div>
<div class="line">The leading dimension of the array ```PerturbationVectorCopy```. \</div>
<div class="line">LDA &gt;= max(1,M)\</div>
<div class="line">```lda = N_Realisations``` \</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">```Sg``` is DOUBLE PRECISION array, dimension (min(M,N))= ```N_Realisations```.  </div>
<div class="line">The singular values of A, sorted so that S(i) &gt;= S(i+1).</div>
<div class="line"> </div>
<div class="line">```U ``` is DOUBLE PRECISION array, dimension ```LDU x N_U``` \      </div>
<div class="line">If JOBU = &#39;S&#39;, U contains the first min(m,n) columns of U</div>
<div class="line">(the left singular vectors, stored columnwise)</div>
<div class="line">          </div>
<div class="line">```LDU``` is INTEGER \</div>
<div class="line">The leading dimension of the array U.\</div>
<div class="line">```ldu = N_Realisations</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
Output</h3>
<div class="fragment"><div class="line"> {Sg[i],}</div>
<div class="line">```L, N_U x N_Realisations</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md14"></a>
Calculation of Projection Matrix</h2>
<p >Back to Contents</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Purpose</h3>
<p >The dgemm routine calculates the product of double precision matrices \ </p><div class="fragment"><div class="line">Here, we want \</div>
<div class="line">``` ProjectionVector = PerturbationVector^T x L </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Code snippet</h3>
<div class="fragment"><div class="line"> {cblas_dgemm(CblasRowMajor,CblasTrans,CblasNoTrans,N_Realisations,minDim,N_U,1.0,PerturbationVector,N_Realisations,L,minDim,0.0,ProjectionVector,minDim);```}</div>
<div class="line"> </div>
<div class="line">#### Input </div>
<div class="line">```CblasRowMajor``` \</div>
<div class="line">Indicates that the matrices are stored in row major order, with the elements of each row of the matrix stored contiguously.</div>
<div class="line"> </div>
<div class="line">```CblasTrans``` \</div>
<div class="line">Enumeration type</div>
<div class="line">indicating that the matrix ```Perturbation Vector``` should be transposed before multiplication. </div>
<div class="line"> </div>
<div class="line">```CblasNoTrans``` \</div>
<div class="line">Enumeration type indicating that ```L</div>
</div><!-- fragment --><p> should not be transposed or conjugate transposed before multiplication.</p>
<div class="fragment"><div class="line">Integers indicating the size of the matrices:</div>
<div class="line"> </div>
<div class="line">A</div>
<div class="line">: m</div>
<div class="line">rows by k</div>
<div class="line">columns\</div>
<div class="line">B</div>
<div class="line">: k</div>
<div class="line">rows by n</div>
<div class="line">columns\</div>
<div class="line">C</div>
<div class="line">: m</div>
<div class="line">rows by n</div>
<div class="line">columns\</div>
<div class="line">Here, ```A = PerturbationVector^T```, ```B=L```, ```C = ProjectionVector```, hence \</div>
<div class="line">```m = N_Realisations``` \</div>
<div class="line">```n = minDim``` \</div>
<div class="line">```k = N_U</div>
</div><!-- fragment --><p >alpha Real value used to scale the product of matrices A and B.\ </p><div class="fragment"><div class="line">A \</div>
<div class="line">Array used to store matrix A (```PerturbationVector``` transposed using CblasTrans in our case)</div>
<div class="line"> </div>
<div class="line">k \</div>
<div class="line">Leading dimension of array A (```PerturbationVector```)</div>
<div class="line">, or the number of elements between successive rows (for row major storage)</div>
<div class="line">in memory. \</div>
<div class="line">```k = N_Realisations</div>
</div><!-- fragment --><p >B \ Array used to store matrix B (<code>L</code> in our case)</p>
<p >n \ Leading dimension of array B (<code>L</code>) , or the number of elements between successive rows (for row major storage) in memory. \ </p><div class="fragment"><div class="line">beta \</div>
<div class="line">Real value used to scale matrix C (```ProjectionVector```)</div>
<div class="line">```beta = 0.0</div>
</div><!-- fragment --><p >C \ Array used to store matrix C (<code>ProjectionVector</code> in our case)</p>
<p >n Leading dimension of array C , or the number of elements between successive rows (for row major storage) in memory. <code>n = minDim</code> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
