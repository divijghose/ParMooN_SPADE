<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ParMooN(SPADE): BLAS and LAPACK routines used in the code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ParMooN(SPADE)<span id="projectnumber">&#160;1.10</span>
   </div>
   <div id="projectbrief">Stochastic ParMooN for analysis, design and estimation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">BLAS and LAPACK routines used in the code </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="contents"></a>
Contents</h1>
<ol type="1">
<li><a class="el" href="md_ExtRoutines.html#monte-carlo-realization-generation">Monte Carlo realization generation</a> <br  />
 a. <a class="el" href="md_ExtRoutines.html#svd-of-covariance-matrix">SVD of Covariance Matrix</a><br  />
 b. <a class="el" href="md_ExtRoutines.html#multiplication-of-truncated-left-singular-value-matrix-with-standard-deviation-matrix">Multiplication of truncated left singular value matrix with standard deviation matrix</a></li>
<li><a class="el" href="md_ExtRoutines.html#do-initialization">DO Initialization</a> <br  />
 a. <a class="el" href="md_ExtRoutines.html#svd-of-perturbation-matrix">SVD of perturbation matrix</a> <br  />
 b. <a class="el" href="md_ExtRoutines.html#calculation-of-projection-matrix">Calculation of Projection Matrix</a></li>
<li><a class="el" href="md_ExtRoutines.html#do-solver">DO Solver</a> <br  />
</li>
</ol>
<h1><a class="anchor" id="monte-carlo-realization-generation"></a>
Monte Carlo Realization generation</h1>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a></p>
<h2><a class="anchor" id="svd-of-covariance-matrix"></a>
SVD of Covariance matrix</h2>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a></p>
<h3><a class="anchor" id="autotoc_md1"></a>
Code Snippet</h3>
<div class="fragment"><div class="line">MKL_INT m1 = N_U, n = N_U, lda = N_U, ldu = N_U, ldvt = N_U, info;</div>
<div class="line">double superb[std::min(N_U, N_U) - 1];</div>
<div class="line"> </div>
<div class="line">double *S = new double[N_U];</div>
<div class="line">double *U = new double[N_U * N_U];</div>
<div class="line">double *Vt = new double[N_U * N_U];</div>
<div class="line"> </div>
<div class="line">info = LAPACKE_dgesvd(LAPACK_ROW_MAJOR, &#39;A&#39;, &#39;A&#39;, m1, n, C, lda,S, U, ldu, Vt, ldvt, superb);</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; endl</div>
<div class="line">        &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">if (info &gt; 0)</div>
<div class="line">{</div>
<div class="line">    printf(&quot;The algorithm computing SVD failed to converge.\n&quot;);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; &quot; SVD COMPUTED&quot; &lt;&lt; endl;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2"></a>
Purpose</h3>
<p >DGESVD computes the singular value decomposition (SVD) of a real <code>N_U x N_U</code> matrix <code>C</code>, also computing the left and/or right singular vectors. The SVD is written </p><pre class="fragment"> C = U * S * Vt
</pre><p ><b>Note that the routine returns V**T, not V.</b></p>
<h3><a class="anchor" id="autotoc_md3"></a>
Input</h3>
<p ><code>MATRIX_LAYOUT</code> indicates whether the input and output matrices are stored in row major order or column major order, where: <br  />
 matrix_layout = <code>LAPACK_ROW_MAJOR</code>, the matrices are stored in row major order.</p>
<p ><code>JOBU</code> is CHARACTER*1 <br  />
 Specifies options for computing all or part of the matrix <br  />
 U := <code>'A'</code>: all M columns of U are returned in array</p>
<p ><code>JOBVT</code> is CHARACTER*1 <br  />
 Specifies options for computing all or part of the matrix <br  />
 VT := <code>'A'</code>: all N rows of V**T are returned in the array VT;</p>
<p ><code>M</code> is INTEGER <br  />
 The number of rows of the input matrix <code>C</code> (Covariance Matrix). <br  />
 <code>m1 = N_U</code>.</p>
<p ><code>N</code> is INTEGER <br  />
 The number of columns of the input matrix <code>C</code> (Covariance Matrix). <br  />
 <code>n = N_U</code>.</p>
<p >A is DOUBLE PRECISION array, dimension (LDA,N), in our case <code>C</code> (Covariance Matrix)<br  />
 On entry, the M-by-N matrix <code>C</code>. <br  />
 On exit, if <code>JOBU != 'O'</code> and <code>JOBVT != 'O'</code>, the contents of <code>C</code> are destroyed.</p>
<p ><code>LDA</code> is INTEGER <br  />
 The leading dimension of the array <code>C</code>. <br  />
 LDA &gt;= max(1,M) <br  />
 <code>lda = N_U</code></p>
<p ><code>S</code> is DOUBLE PRECISION array, dimension (min(M,N))= <code>N_U</code>. <br  />
 The singular values of A, sorted so that S(i) &gt;= S(i+1).</p>
<p ><code>U</code> is DOUBLE PRECISION array, dimension <code>LDU x N_U</code> <br  />
 If <code>JOBU = 'A'</code>, U contains the M-by-M orthogonal matrix U;</p>
<p ><code>LDU</code> is INTEGER <br  />
 The leading dimension of the array U.<br  />
 <code>ldu = N_U</code></p>
<p ><code>Vt</code> is DOUBLE PRECISION array, <code>LDVT x N_U</code> If JOBVT = 'A', <code>Vt</code> contains the <code>N_U x N_U</code> orthogonal matrix V**T</p>
<p ><code>LDVT</code> is INTEGER <br  />
 The leading dimension of the array VT. <br  />
 <code>ldvt = N_U</code></p>
<h3><a class="anchor" id="autotoc_md4"></a>
Output</h3>
<p ><code>S[i], 0&lt;=i&lt;N_U</code> <br  />
 <code>U, N_U x N_U</code> <br  />
 <code>Vt, N_U x N_U</code></p>
<hr  />
 <h2><a class="anchor" id="multiplication-of-truncated-left-singular-value-matrix-with-standard-deviation-matrix"></a>
Multiplication of truncated left singular value matrix with standard deviation matrix</h2>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a></p>
<h3><a class="anchor" id="autotoc_md5"></a>
Purpose</h3>
<p >The dgemm routine calculates the product of double precision matrices <br  />
 <code>C = alpha*(A x B) + k*C</code><br  />
 Here, we want <br  />
 <code>RealizationVector = Ut x Z</code></p>
<h3><a class="anchor" id="autotoc_md6"></a>
Code snippet</h3>
<p ><code>cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,m, n, k, alpha, A, k, B, n, beta, C, n);</code></p>
<h3><a class="anchor" id="autotoc_md7"></a>
Input</h3>
<p ><code>CblasRowMajor</code> <br  />
 Indicates that the matrices are stored in row major order, with the elements of each row of the matrix stored contiguously.</p>
<p ><code>CblasNoTrans</code> <br  />
 Enumeration type indicating that the matrices A and B should not be transposed or conjugate transposed before multiplication.</p>
<p >m, n, k Integers indicating the size of the matrices:</p>
<p >A : m rows by k columns<br  />
 B : k rows by n columns<br  />
 C : m rows by n columns<br  />
 Here, <code>A = Ut</code>, <code>B=Z</code>, <code>C = RealizationVector</code>, hence <br  />
 <code>m = N_U</code> <br  />
 <code>n = N_Realisations</code> <br  />
 <code>k = modDim</code></p>
<p >alpha Real value used to scale the product of matrices A and B.<br  />
 <code>alpha = 1.0</code></p>
<p >A <br  />
 Array used to store matrix A (<code>Ut</code> in our case)</p>
<p >k <br  />
 Leading dimension of array A (<code>Ut</code>) , or the number of elements between successive rows (for row major storage) in memory. <br  />
 <code>k = modDim</code></p>
<p >B <br  />
 Array used to store matrix B (<code>Z</code> in our case)</p>
<p >n <br  />
 Leading dimension of array B (<code>Z</code>) , or the number of elements between successive rows (for row major storage) in memory. <br  />
 <code>n = N_Realisations</code></p>
<p >beta <br  />
 Real value used to scale matrix C (<code>RealizationVector</code>) <code>beta = 0.0</code></p>
<p >C <br  />
 Array used to store matrix C (<code>RealizationVector</code> in our case)</p>
<p >n Leading dimension of array C , or the number of elements between successive rows (for row major storage) in memory. <code>n = N_Realisations</code> </p><hr  />
<h1><a class="anchor" id="do-initialization"></a>
DO Initialization</h1>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a> </p>
<h2><a class="anchor" id="svd-of-perturbation-matrix"></a>
SVD of perturbation matrix</h2>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a></p><ol type="1">
<li><a class="el" href="md_ExtRoutines.html#if-number-of-realisations-is-greater-than-number-of-degrees-of-freedom">If N_Realisations &gt; N_U</a></li>
<li><a class="el" href="md_ExtRoutines.html#if-number-of-degrees-of-freedom-is-greater-than-number-of-realisations">If N_U &gt; N_Realisations</a></li>
</ol>
<h3><a class="anchor" id="if-number-of-realisations-is-greater-than-number-of-degrees-of-freedom"></a>
If number of realisations is greater than number of degrees of freedom</h3>
<p ><a class="el" href="md_ExtRoutines.html#svd-of-perturbation-matrix">Back to SVD of perturbation matrix</a> <br  />
 <code>min(N_R,N_U) = N_U</code></p>
<div class="fragment"><div class="line">int minDim = std::min(N_U,N_Realisations);</div>
<div class="line">//Here, minDim = N_U</div>
<div class="line">MKL_INT mDO = N_U, nDO = N_Realisations, ldaDO = N_Realisations, lduDO = minDim, ldvtDO = N_Realisations, infoDO;</div>
<div class="line">double superbDO[minDim-1];</div>
<div class="line"> </div>
<div class="line">double* PerturbationVectorCopy = new double[N_U * N_Realisations]();</div>
<div class="line">memcpy(PerturbationVectorCopy,PerturbationVector,N_U*N_Realisations*SizeOfDouble);</div>
<div class="line"> </div>
<div class="line">double* Sg = new double[minDim];</div>
<div class="line">double* L = new double[N_U*minDim];</div>
<div class="line">double* Rt = new double[minDim*N_Realisations];</div>
<div class="line"> </div>
<div class="line">infoDO = LAPACKE_dgesvd( LAPACK_ROW_MAJOR, &#39;S&#39;, &#39;N&#39;, mDO, nDO, PerturbationVectorCopy, ldaDO,</div>
<div class="line">                    Sg, L, lduDO, Rt, ldvtDO, superbDO );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">if( infoDO &gt; 0 ) {</div>
<div class="line">    printf( &quot;The algorithm computing SVD for DO failed to converge.\n&quot; );</div>
<div class="line">    exit( 1 );</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; &quot; DO SVD COMPUTED &quot; &lt;&lt;endl;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Purpose</h3>
<p >DGESVD computes the singular value decomposition (SVD) of a real <code>N_U x N_Realisations</code> matrix <code>PerturbationVector</code>, also computing the left and/or right singular vectors. The SVD is written </p><pre class="fragment"> PerturbationVector = L * Sg * Rt
</pre><p ><b>Note that the routine returns R**T, not R.</b></p>
<h3><a class="anchor" id="autotoc_md9"></a>
Input</h3>
<p ><code>MATRIX_LAYOUT</code> indicates whether the input and output matrices are stored in row major order or column major order, where:<br  />
 matrix_layout = <code>LAPACK_ROW_MAJOR</code>, the matrices are stored in row major order.</p>
<p ><code>JOBU</code> is CHARACTER*1<br  />
 Specifies options for computing all or part of the matrix <br  />
 L := <code>'S'</code>: the first <code>min(N_U,N_Realisation)</code> columns of U (the left singular matrix)<br  />
 <b>Here we are assuming</b> <code>N_Realisations &gt; N_U</code>, <b>hence U will have dimension</b> <code>N_U x N_U</code></p>
<p ><code>JOBVT</code> is CHARACTER*1 <br  />
 Specifies options for computing all or part of the matrix<br  />
 VT := <code>'N'</code>: no rows of V**T (no right singular vectors) are computed.<br  />
</p>
<p >`<code>M</code> is INTEGER <br  />
 The number of rows of the input matrix <code>PerturbationVectorCopy</code> (Copy of <code>PerturbationVector</code>). <br  />
 <code>mDO = N_U</code>.</p>
<p ><code>N</code> is INTEGER <br  />
 The number of columns of the input matrix <code>PerturbationVectorCopy</code>(Copy of <code>PerturbationVector</code>). <br  />
 <code>nDO = N_Realisations</code>.</p>
<p >A is DOUBLE PRECISION array, dimension (LDA,N), in our case <code>PerturbationVectorCopy</code> (Copy of <code>PerturbationVector</code>)<br  />
 On entry, the M-by-N matrix <code>PerturbationVectorCopy</code>. <br  />
 On exit, if <code>JOBU != 'O'</code> and <code>JOBVT != 'O'</code>, the contents of <code>PerturbationVectorCopy</code> are destroyed. (Hence we are using <code>PerturbationVectorCopy</code> and not <code>PerturbationVector</code>)</p>
<p ><code>LDA</code> is INTEGER <br  />
 The leading dimension of the array <code>PerturbationVectorCopy</code>. <br  />
 LDA &gt;= max(1,M)<br  />
 <code>lda = N_Realisations</code> <br  />
 <b>Assumption of <code>N_Realisations &gt; N_U</code> also applies here</b></p>
<p ><code>Sg</code> is DOUBLE PRECISION array, dimension (min(M,N))= <code>N_U</code>. <br  />
 The singular values of A, sorted so that S(i) &gt;= S(i+1).</p>
<p ><code>U</code> is DOUBLE PRECISION array, dimension <code>LDU x N_U</code> <br  />
 <br  />
 If JOBU = 'S', U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise)</p>
<p ><code>LDU</code> is INTEGER <br  />
 The leading dimension of the array U.<br  />
 <code>ldu = N_U</code></p>
<h3><a class="anchor" id="autotoc_md10"></a>
Output</h3>
<p ><code>Sg[i], 0&lt;=i&lt;N_U</code> <br  />
 <code>L, N_U x N_U</code> <br  />
 </p><hr  />
<h3><a class="anchor" id="if-number-of-degrees-of-freedom-is-greater-than-number-of-realisations"></a>
If number of degrees of freedom is greater than number of realisations</h3>
<p ><a class="el" href="md_ExtRoutines.html#svd-of-perturbation-matrix">Back to SVD of perturbation matrix</a> <br  />
 <code>min(N_R,N_U) = N_Realisations</code></p>
<div class="fragment"><div class="line">int minDim = std::min(N_U,N_Realisations);</div>
<div class="line">//Here, minDim = N_Realisations</div>
<div class="line">MKL_INT mDO = N_U, nDO = N_Realisations, ldaDO = N_Realisations, lduDO = minDim, ldvtDO = N_Realisations, infoDO;</div>
<div class="line">double superbDO[minDim-1];</div>
<div class="line"> </div>
<div class="line">double* PerturbationVectorCopy = new double[N_U * N_Realisations]();</div>
<div class="line">memcpy(PerturbationVectorCopy,PerturbationVector,N_U*N_Realisations*SizeOfDouble);</div>
<div class="line"> </div>
<div class="line">double* Sg = new double[minDim];</div>
<div class="line">double* L = new double[N_U*minDim];</div>
<div class="line">double* Rt = new double[minDim*N_Realisations];</div>
<div class="line"> </div>
<div class="line">infoDO = LAPACKE_dgesvd( LAPACK_ROW_MAJOR, &#39;S&#39;, &#39;N&#39;, mDO, nDO, PerturbationVectorCopy, ldaDO,</div>
<div class="line">                    Sg, L, lduDO, Rt, ldvtDO, superbDO );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">if( infoDO &gt; 0 ) {</div>
<div class="line">    printf( &quot;The algorithm computing SVD for DO failed to converge.\n&quot; );</div>
<div class="line">    exit( 1 );</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; &quot; DO SVD COMPUTED &quot; &lt;&lt;endl;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Purpose</h3>
<p >DGESVD computes the singular value decomposition (SVD) of a real <code>N_U x N_Realisations</code> matrix <code>PerturbationVector</code>, also computing the left and/or right singular vectors. The SVD is written </p><pre class="fragment"> PerturbationVector = L * Sg * Rt
</pre><p ><b>Note that the routine returns R**T, not R.</b></p>
<h3><a class="anchor" id="autotoc_md12"></a>
Input</h3>
<p ><code>MATRIX_LAYOUT</code> indicates whether the input and output matrices are stored in row major order or column major order, where:<br  />
 matrix_layout = <code>LAPACK_ROW_MAJOR</code>, the matrices are stored in row major order.</p>
<p ><code>JOBU</code> is CHARACTER*1<br  />
 Specifies options for computing all or part of the matrix <br  />
 L := <code>'S'</code> : the first <code>min(N_U,N_Realisation)</code> columns of U (the left singular matrix)<br  />
 <b>Here we are assuming</b> <code>N_U &gt; N_Realisations</code>, <b>hence U will have dimension</b> <code>N_U x N_Realisations</code></p>
<p ><code>JOBVT</code> is CHARACTER*1 <br  />
 Specifies options for computing all or part of the matrix<br  />
 VT := <code>'N'</code>: no rows of V**T (no right singular vectors) are computed.<br  />
</p>
<p ><code>M</code> is INTEGER <br  />
 The number of rows of the input matrix <code>PerturbationVectorCopy</code> (Copy of <code>PerturbationVector</code>). <br  />
 <code>mDO = N_U</code>.</p>
<p ><code>N</code> is INTEGER <br  />
 The number of columns of the input matrix <code>PerturbationVectorCopy</code> (Copy of <code>PerturbationVector</code>). <br  />
 <code>nDO = N_Realisations</code>.</p>
<p >A is DOUBLE PRECISION array, dimension (LDA,N), in our case <code>PerturbationVectorCopy</code> (Copy of <code>PerturbationVector</code>)<br  />
 On entry, the M-by-N matrix <code>PerturbationVectorCopy</code>. <br  />
 On exit, if <code>JOBU != 'O'</code> and <code>JOBVT != 'O'</code>, the contents of <code>PerturbationVectorCopy</code> are destroyed.(Hence we are using <code>PerturbationVectorCopy</code> and not <code>PerturbationVector</code>)</p>
<p ><code>LDA</code> is INTEGER <br  />
 The leading dimension of the array <code>PerturbationVectorCopy</code>. <br  />
 LDA &gt;= max(1,M)<br  />
 <code>lda = N_Realisations</code> <br  />
</p>
<p ><code>Sg</code> is DOUBLE PRECISION array, dimension (min(M,N))= <code>N_Realisations</code>. <br  />
 The singular values of A, sorted so that S(i) &gt;= S(i+1).</p>
<p ><code>U</code> is DOUBLE PRECISION array, dimension <code>LDU x N_U</code> <br  />
 <br  />
 If JOBU = 'S', U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise)</p>
<p ><code>LDU</code> is INTEGER <br  />
 The leading dimension of the array U.<br  />
 <code>ldu = N_Realisations</code></p>
<h3><a class="anchor" id="autotoc_md13"></a>
Output</h3>
<p ><code>Sg[i], 0&lt;=i&lt;N_Realisations</code> <br  />
 <code>L, N_U x N_Realisations</code></p>
<hr  />
<h2><a class="anchor" id="calculation-of-projection-matrix"></a>
Calculation of Projection Matrix</h2>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a> </p>
<h3><a class="anchor" id="autotoc_md14"></a>
Purpose</h3>
<p >The dgemm routine calculates the product of double precision matrices <br  />
 <code>C = alpha*(A x B) + k*C</code><br  />
 Here, we want <br  />
 <code>ProjectionVector = PerturbationVector^T x L</code></p>
<h3><a class="anchor" id="autotoc_md15"></a>
Code snippet</h3>
<div class="fragment"><div class="line">cblas_dgemm(CblasRowMajor,CblasTrans,CblasNoTrans,N_Realisations,minDim,N_U,1.0,PerturbationVector,N_Realisations,L,minDim,0.0,ProjectionVector,minDim);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Input</h3>
<p ><code>CblasRowMajor</code> <br  />
 Indicates that the matrices are stored in row major order, with the elements of each row of the matrix stored contiguously.</p>
<p ><code>CblasTrans</code> <br  />
 Enumeration type indicating that the matrix <code>Perturbation Vector</code> should be transposed before multiplication.</p>
<p ><code>CblasNoTrans</code> <br  />
 Enumeration type indicating that <code>L</code> should not be transposed or conjugate transposed before multiplication.</p>
<p ><code>m, n, k</code> Integers indicating the size of the matrices:</p>
<p >A : m rows by k columns<br  />
 B : k rows by n columns<br  />
 C : m rows by n columns<br  />
 Here, <code>A = PerturbationVector^T</code>, <code>B=L</code>, <code>C = ProjectionVector</code>, hence <br  />
 <code>m = N_Realisations</code> <br  />
 <code>n = minDim</code> <br  />
 <code>k = N_U</code></p>
<p >alpha Real value used to scale the product of matrices A and B.<br  />
 <code>alpha = 1.0</code></p>
<p >A <br  />
 Array used to store matrix A (<code>PerturbationVector</code> transposed using CblasTrans in our case)</p>
<p >k <br  />
 Leading dimension of array A (<code>PerturbationVector</code>) , or the number of elements between successive rows (for row major storage) in memory. <br  />
 <code>k = N_Realisations</code></p>
<p >B <br  />
 Array used to store matrix B (<code>L</code> in our case)</p>
<p >n <br  />
 Leading dimension of array B (<code>L</code>) , or the number of elements between successive rows (for row major storage) in memory. <br  />
 <code>n = minDim</code></p>
<p >beta <br  />
 Real value used to scale matrix C (<code>ProjectionVector</code>) <code>beta = 0.0</code></p>
<p >C <br  />
 Array used to store matrix C (<code>ProjectionVector</code> in our case)</p>
<p >n Leading dimension of array C , or the number of elements between successive rows (for row major storage) in memory. <code>n = minDim</code></p>
<hr  />
<h1><a class="anchor" id="do-solver"></a>
DO Solver</h1>
<p ><a class="el" href="md_ExtRoutines.html#contents">Back to Contents</a></p>
<h2><a class="anchor" id="autotoc_md17"></a>
Covariance Matrix</h2>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
